<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta http-equiv="Cache-Control" content="no-store, max-age=0, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Visionnage sécurisé (30s)</title>

<style>
  :root{color-scheme:dark}
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  .center{display:flex;align-items:center;justify-content:center;flex-direction:column;height:100%;}
  #msg{padding:12px 18px;color:#ddd}
  #login{display:flex;gap:10px;align-items:center;margin-bottom:12px}
  input[type=password]{padding:8px;border-radius:8px;background:#111;border:1px solid #333;color:#fff}
  button{padding:9px 14px;border-radius:8px;background:#1e90ff;border:none;color:#fff;cursor:pointer}
  button:disabled{background:#333;cursor:not-allowed}
  canvas{max-width:94vw;border:1px solid #222;box-shadow:0 0 20px rgba(0,0,0,.6);background:#111}
  #log{position:fixed;left:8px;bottom:8px;padding:6px 10px;background:rgba(0,0,0,.6);color:#9f9;font-size:13px;border-radius:6px;max-width:calc(100vw - 16px);white-space:pre-wrap}
  #overlay{position:fixed;inset:0;background:rgba(0,0,0,.92);display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:9999}
  .hidden{display:none}
</style>

</head>
<body>
<div id="overlay" aria-hidden="false">
  <div style="text-align:center; padding:10px; max-width:900px;">
    <h1 style="margin:0 0 8px;font-weight:600">Document confidentiel — affichage sécurisé</h1>
    <div id="msg">Entrez le mot de passe pour déchiffrer le document (affichage 30s)</div>
    <div id="login" style="margin-top:12px;">
      <label for="pw" class="sr-only" style="display:none">Mot de passe</label>
      <input id="pw" type="password" autocomplete="off" placeholder="Mot de passe" autofocus>
      <button id="btn" disabled>Déchiffrer</button>
    </div>
    <div style="margin-top:8px;color:#bbb;font-size:13px">Attention : l’utilisateur ne peut pas télécharger ni imprimer depuis la page. La vue ferme si capture détectée.</div>
  </div>
</div>

<div class="center">
  <div id="s" style="height:48px"></div>
  <canvas id="cv" class="hidden" role="img" aria-label="Document sécurisé"></canvas>
</div>

<div id="log" class="hidden" aria-hidden="true"></div>

<!-- libs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/openpgp/5.11.2/openpgp.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.min.js"></script>
<script>pdfjsLib.GlobalWorkerOptions.workerSrc="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.worker.min.js";</script>

<script>
/* --------------------------
   CONFIGURATION (à modifier si besoin)
   - CHEMIN GPG : emplacement relatif dans le repo (case-sensitive)
   -------------------------- */
const GPG_URL = '/secure/LAB-EXAMS-20250926-ICL-01-Q7P3-000001 (1)_protected.pdf.gpg';
const DISPLAY_SECONDS = 30;

/* --------------------------
   UI helpers & logging
   -------------------------- */
const overlay = document.getElementById('overlay');
const pw = document.getElementById('pw');
const btn = document.getElementById('btn');
const s = id => document.getElementById(id);
const cv = document.getElementById('cv');
const logBox = document.getElementById('log');
let showLog = true;

function log(...args){
  if(!showLog) return;
  const t = new Date().toISOString().slice(11,23);
  const line = t + '  ' + args.map(a=>typeof a==='object'?JSON.stringify(a):String(a)).join(' ');
  logBox.textContent = (logBox.textContent?logBox.textContent + '\n':'') + line;
  logBox.classList.remove('hidden');
  console.debug(...args);
}
function setMsg(txt){ document.getElementById('msg').textContent = txt; }
function blockAndClose(reason){
  try{ log('BLOCK ->', reason); }catch(e){}
  // Effacer canvas avant fermeture
  try{ cv.width = 1; cv.height = 1; }catch(e){}
  // petit délai pour log
  setTimeout(()=>{ window.close?.(); location.replace('about:blank'); }, 250);
}

/* --------------------------
   Défenses activées
   -------------------------- */
// désactiver menu contextuel / sélection / copier
document.addEventListener('contextmenu', e => { e.preventDefault(); log('contextmenu blocked'); blockAndClose('contextmenu'); }, true);
['copy','cut','paste','selectstart','dragstart'].forEach(ev=>document.addEventListener(ev,e=>{ e.preventDefault(); log(ev+' blocked'); blockAndClose(ev); }, true));

// bloquer impressions/sauvegarde via raccourcis
document.addEventListener('keydown', e => {
  const k = e.key.toLowerCase();
  if((e.ctrlKey||e.metaKey) && (k==='s' || k==='p' || k==='u' || k==='w')){ e.preventDefault(); log('shortcut blocked', k); blockAndClose('shortcut:'+k); }
  if(k==='printscreen'){ e.preventDefault(); log('printscreen key'); blockAndClose('printscreen'); }
}, true);

// si fenêtre perd focus -> fermer
window.addEventListener('blur', ()=>{ log('window blur -> close'); blockAndClose('blur'); });

// surveiller visuel pour detection rapide (ex: user appuie sur bouton capture fourni par extension)
let captureDetected = false;
function detectPotentialCapture(){
  // detection heuristique : grande variation du nombre de plugins / chrome.runtime existence
  try {
    if(navigator.plugins && navigator.plugins.length > 100){ log('many plugins'); captureDetected = true; }
    if(window.chrome && window.chrome.runtime){ log('chrome.runtime present'); /* possible extension */ }
  } catch(e){}
  if(captureDetected) blockAndClose('extension-detected');
}

/* --------------------------
   Bouton / flux principal
   -------------------------- */
pw.addEventListener('input', ()=> btn.disabled = !pw.value);

btn.addEventListener('click', async () => {
  btn.disabled = true;
  setMsg('Chargement du fichier chiffré…');
  log('Start: fetching', GPG_URL);
  try {
    const resp = await fetch(GPG_URL, { cache: 'no-store' });
    if(!resp.ok) throw new Error('HTTP '+resp.status);
    const encArray = new Uint8Array(await resp.arrayBuffer());
    log('Fetched bytes', encArray.byteLength);

    setMsg('Déchiffrement en mémoire (OpenPGP.js)…');
    const message = await openpgp.readMessage({ binaryMessage: encArray });
    const dec = await openpgp.decrypt({ message, passwords: [pw.value], format: 'binary' });
    // dec.data is Uint8Array or ArrayBuffer depending on lib version
    let pdfData = dec.data;
    if(pdfData instanceof ArrayBuffer) pdfData = new Uint8Array(pdfData);
    log('Decryption OK length=', pdfData.byteLength);
    // zero the encrypted buffer
    encArray.fill(0);

    // Affichage page 1 via PDF.js
    setMsg('Rendu du document (page 1)…');
    const pdf = await pdfjsLib.getDocument({ data: pdfData, disableFontFace:true }).promise;
    const page = await pdf.getPage(1);
    const viewport = page.getViewport({ scale: 1.5 });
    cv.classList.remove('hidden');
    cv.width = viewport.width;
    cv.height = viewport.height;
    const ctx = cv.getContext('2d', { alpha: false });
    await page.render({ canvasContext: ctx, viewport }).promise;
    setMsg('Affichage temporaire — fermeture automatique dans '+DISPLAY_SECONDS+' s');
    overlay.classList.add('hidden');
    log('Rendered; scheduling destruction in', DISPLAY_SECONDS);

    // schedule close and secure erase of pdfData
    setTimeout(()=>{
      try{ if(pdfData && pdfData.fill) pdfData.fill(0); }catch(e){}
      blockAndClose('timeout');
    }, DISPLAY_SECONDS * 1000);

    // surveillance simple des tentatives de capture
    setInterval(detectPotentialCapture, 1500);

    // Add additional event listeners (mouse buttons, selection)
    ['mousedown','mouseup','click','dblclick','mousemove','wheel'].forEach(ev=>{
      window.addEventListener(ev, e=>{
        // after unlocked, any right-click or middle click triggers close
        if(e.button === 2 || e.button === 1){ log('mouse button', e.button); blockAndClose('mouse-button'); }
      }, true);
    });

  } catch(err){
    log('ERROR', String(err));
    setMsg('Erreur : '+ (err && err.message ? err.message : String(err)));
    pw.value = '';
    btn.disabled = true;
    // on remet la superposition visible afin que l'utilisateur puisse réessayer
    overlay.classList.remove('hidden');
  }
});

/* --------------------------
   Quick self-test helper (pour diagnostiquer)
   Affiche des checks basiques afin de savoir pourquoi ça planterait.
   -------------------------- */
(function selfTest(){
  try {
    log('Selftest start: runtime check');
    log('openpgp version', openpgp.version || 'unknown');
    log('pdfjsLib version', pdfjsLib.version || 'unknown');
    // test fetch HEAD (no-op) to check permissions (CORS / path)
    fetch(GPG_URL, {method:'HEAD', cache:'no-store'}).then(r=>log('HEAD status', r.status)).catch(e=>log('HEAD error', String(e)));
  }catch(e){ log('selftest error', e); }
})();
</script>
</body>
</html>
/* --- auto-pass via URL fragment --- */
const urlHash = new URLSearchParams(location.hash.slice(1));
const urlQuery = new URLSearchParams(location.search); // secours si tu préfères ?pw=... (moins sûr)
const AUTO_PASS = urlHash.get('pw') || urlQuery.get('pw'); // #pw=xxxx (recommandé)
/* si un mot de passe est présent dans l’URL, on préremplit et on clique pour déchiffrer */
document.addEventListener('DOMContentLoaded', () => {
  if (AUTO_PASS) {
    pw.value = decodeURIComponent(AUTO_PASS);
    btn.disabled = false;
    btn.click();
  }
});
